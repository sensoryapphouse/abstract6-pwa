<!DOCTYPE html>
<html>

<head>
	<title>Sensory Abstract 6 - relaxing digital art effects</title>
	<link rel="manifest" href="manifest.json">
	<meta name="viewport" content="width=device-width,initial-scale=1">
	<link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon">
	<link href="css/index.css" rel="stylesheet" />
	<script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>
	<script type="text/javascript" src="webgl-utils.js"></script>
	<script type="text/javascript" src="main.js"></script>

	<script id="shader-1-fs" type="f">
		precision highp float;
uniform vec2 resolution;
uniform vec2 mouse;
uniform float time;
uniform float Param1;
uniform float Param2;
uniform float Param3;
uniform float Param4;
const float fRadius = 0.008;
const float ySpeed = 1.25;
const float bubblePopHeight = 1.0;
const float bubbleSpreadDist = 2.0;
vec3 bokeh(vec3 d)
{
	vec2 uv = d.xy -1. + 2.0*gl_FragCoord.xy / resolution.xy;
    uv.x *=  resolution.x / resolution.y;
    
    vec3 color = vec3(0.0);

        // bubbles
    for( int i=0; i<20; i++ )
    {
            // bubble seeds
        float pha = tan(float(i)*6.+1.0)*0.5 + 0.5;
        float siz = pow( cos(float(i)*2.4+4.0) * 0.5 + ySpeed, 4.0 );
        float pox = cos(float(i)*2.55+3.1) * resolution.x / resolution.y;
        
            // buble size, position and color
        float rad = fRadius + sin(float(i))*0.12+0.29;
        vec2  pos = vec2( pox+sin(time/50.+pha+siz), -abs(bubblePopHeight)-rad + (bubbleSpreadDist+2.0*rad)
                         *mod(pha+0.1*(time/5.)*(0.2+0.8*siz),1.0)) * vec2(1.0, 1.0);
        float dis = length( uv - pos );
        vec3  col = mix( vec3(0.2, 0.5, 0.1), vec3(0.2,0.3,0.6), 0.2+0.2*sin(float(i)*sin(time*pox*0.03)+1.9));
        
            // render
        color += col.xyz *(1.- smoothstep( rad*(0.65+0.20*sin(pox*time)), rad, dis )) * (1.0 - cos(pox*time));
    }
	return color;
}

vec3 stripey(vec3 d, int v)
{
vec2 coord = d.xy + gl_FragCoord.xy / resolution;
float color = 0.0;
color += (sin(((coord.x * 50.0) + cos(time + (coord.y * 10.0))) + sin((coord.x * 50.0) + (time * 2.0))) * .125);
//color += (cos(((coord.x * 20.0) + sin(time + (coord.y * 10.0))) + cos((coord.x * 50.0) + (time * 2.0))) * 2.0);
//color += (cos(((coord.x * 30.0) + sin(time + (coord.y * 10.0))) + cos((coord.x * 50.0) + (time * 2.0))) * 2.0);
if (v == 1)
	color += (sin(((coord.x * 10.0) + cos(time + (coord.y * 10.0))) + sin((coord.x * 50.0) + (time * 2.0))) * .5);
return vec3(color + coord.y, color + coord.x, color);
}

vec3 trippy(vec3 d, float v)
{
vec2 uv = d.xy+(gl_FragCoord.xy / resolution.xy);
if (v == 32.) uv.y = 1. - uv.y;
vec2 r;
r = resolution.xy/v;
float t = time/4.;
float c = fract( sin(uv.x * r.x*0.8) *
		 sin(uv.y * r.y*0.08 ) + t ); 
uv.x += (uv.x+uv.y) +  c;
return vec3(c, c*mod(t+uv.x,1.5), 0.5 );
}

float FalloffSpeed = 2.0;
float RotationSpeed = 1.0;
vec4 Color1 = vec4(1.0, 0.0, 0.0, 1.0);
vec4 Color2 = vec4(1.0, 1.0, 0.0, 1.0);
vec3 OrangeTint(vec3 d) {
vec2 uv = (d.xy + gl_FragCoord.xy / resolution.xy) * 2.0 - 1.0;
float T = time * RotationSpeed;
float value = distance(uv, vec2(sin(T), cos(T)));
return vec3(mix(Color1, Color2, value / FalloffSpeed));
}

vec3 rota(vec3 gg){
return vec3(sin(sin(gg.x*10.)+(cos(gg.y*3.2)*2.3)+cos(gg.z*1.3))+sin(gg.x*7.),
	    cos(gg.y*cos(gg.z*1.241)+sin(gg.x*1.17)+cos(gg.y*3.4)), 
	    1.2*cos(gg.y*.9))+sin(gg.x+time*0.1)+cos(gg.z*1.3);
}
vec3 swirls(vec3 d) {
vec2 position = d.xy +gl_FragCoord.yx / resolution.xy;
vec3 gg=vec3(position,time*0.1);
gg=rota(gg);
gg=rota(gg);
gg=rota(gg);
vec3 color = vec3(position.xy,1.);
return vec3(gg);
}

vec3 bgColor = vec3(0.01, 0.3, 0.1);
vec3 rectColor = vec3(0.01, 0.2, 0.3);

const float noiseIntensity = 12.; // 2., 6., 12
const float noiseDefinition = .2;  //.1, .2, .4 slow time
const vec2 glowPos = vec2(-1., 0.);

float random(vec2 co){return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);}

float noise( in vec2 p )
{
p*=noiseIntensity;
vec2 i = floor( p );
vec2 f = fract( p );
vec2 u = f*f*(3.0-2.0*f);
return mix( mix( random( i + vec2(0.0,0.0) ), 
	     random( i + vec2(1.0,0.0) ), u.x),
	mix( random( i + vec2(0.0,1.0) ), 
	     random( i + vec2(1.0,1.0) ), u.x), u.y);
}

float fbm( in vec2 uv )
{	
uv *= 5.0;
mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );
float f  = 0.5000*noise( uv ); uv = m*uv;
f += 0.2500*noise( uv ); uv = m*uv;
f += 0.1250*noise( uv ); uv = m*uv;
f += 0.0625*noise( uv ); uv = m*uv;
f = 0.5 + 0.5*f;
return f;
}

vec3 bg(vec2 uv)
{
float velocity = time/4.6;
float intensity = (sin(uv.y*3.+velocity*2.))*1.1+1.8;
uv.y -= 0.;
vec2 bp = uv+glowPos;
uv *= noiseDefinition;
float rb = fbm(vec2(uv.x*.5-velocity*.03, uv.y))*.21;
uv += rb;
float rz = fbm(uv*.9+vec2(velocity*.35, 0.0));
rz *= dot(bp*intensity/8.,bp)+1.2;
vec3 col = bgColor/(.1-rz);
return sqrt(abs(col));
}

vec3 greenRain(vec3 d)
{
vec2 uv = d.xy + gl_FragCoord.xy / resolution.xy * 2. - 1.;
uv.x *= resolution.x/resolution.y;
return vec3(bg(uv.yx)*(2.-abs(uv.y*2.)));
}

vec3 col2 (vec3 d)
{
vec2 uv = (d.xy + gl_FragCoord.xy / resolution.xy )*6.0;
vec2 uv0=uv;
float i0=1.5;
float i1=0.95;
float i2=1.5;
vec2 i4=vec2(0.0,0.0);
for(int s=0;s<10;s++)
{
	vec2 r;
	r=vec2(cos(uv.y*i0-i4.y+time/i1),sin(uv.x*i0+i4.x+time/i1))/i2;
	r+=vec2(-r.y,r.x)*0.2;
	uv.xy+=r;

	i0*=1.93;
	i1*=1.45; //speed
	i2*=10.9; //blur
	i4+=r.xy*1.0+0.5*time*i1;
}
float r=sin(uv.x-time)*0.2+1.1;
float b=sin(uv.y+time)*0.5+0.5;
float g=sin((sqrt(uv.x*uv.x+uv.y*uv.y)+time))*0.8+0.1;
vec3 c=sqrt(vec3(r*b,g*r,b*g));
return c;
}


vec2 rot(vec2 p, float a)
{
float sa = sin(a), ca = cos(a);
return p * mat2(ca, -sa, sa, ca);
}  

bool intersect(vec3 origin, vec3 ray, float radius, out float t, out vec3 n) {
vec3 L = -origin;
float radiusSquared = radius * radius;
float tca = dot(L, ray);
if (tca < 0.0) return false;
float d2 = dot(L, L) - tca * tca;
if (d2 > radiusSquared) return false;
float thc = sqrt(radiusSquared - d2);
t = tca - thc;
n = normalize(origin + ray * t);
return true;
}

vec3 background()
{
if (Param4 == 2.) return bokeh(vec3(0.));
else if (Param4 == 1.) return col2(vec3(0.));
else if (Param4 == 3.) return (greenRain(vec3(0.))/1.2);
else if (Param4 == 4.) return swirls(vec3(0.))/1.8;
else if (Param4 == 5.) return stripey(vec3(0.),0)/2.;
else return trippy(vec3(0.),13.)/1.5;
}

#define HEIGHT 10. // 10 = ball, 40 = line (horizontal and vertical) 
vec3 _col;

float sdCylinder( vec3 p, vec2 h ){vec2 d = abs(vec2(length(p.xz),p.y)) - h;return min(max(d.x,d.y),.0) + length(max(d,0.0));}
float smin( float a, float b, float k ){float h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );return mix( b, a, h ) - k*h*(1.0-h);}
float smax(float a, float b, float k){return smin(a, b, -k);}
float sminCol( float a, float b, float k, vec3 col1, vec3 col2 ){float h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );_col = mix(col1,col2,h);return mix( b, a, h ) - k*h*(1.0-h);}
vec3 e(vec3 p, vec3 ax, float ro){return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);}

float WaveletNoise(vec3 p, float z, float k) {
    float d=0.,s=1.,m=0., a;
    for(float i=0.; i<3.; i++) {
        vec3 q = p*s, g=fract(floor(q)*vec3(123.34,233.53,314.15));
    	g += dot(g, g+23.234);
		a = fract(g.x*g.y)*1e3 +z*(mod(g.x+g.y, 2.)-1.); // add vorticity
        q = (fract(q)-.5);
        q = e(q, normalize(tan(g+.1)), a);
        d += sin(q.x*10.+z)*smoothstep(.25, .0, dot(q,q))/s;
        p = e(p,normalize(vec3(-1,1,0)),atan(sqrt(2.)))+i; //rotate along the magic angle
        m += 1./s;
        s *= k; 
    }
    return d/m;
}
  
float map( in vec3 pos )
{
    float nx = WaveletNoise(pos*0.1+vec3(0.0,time/3.,0.0), time*.1, 1.15)*1.9;
    float nz = WaveletNoise(pos*0.1+vec3(0.0,time/3.,0.0) + 10.0, time*.1, 1.15)*1.9;
    vec3 p2 = pos;
    p2.x += nx;
    p2.z += nz;
    float d1 = sdCylinder(p2,vec2(4.0,HEIGHT))-1.0;
    d1 = smax(d1-sin(time*7.0+pos.y*0.4),d1,-3.0);
    float cmod = 0.5+sin(nx*1.3-nz*2.0)*0.5;
    _col = vec3(0.55,0.45,0.05)*1.2;
    vec3 _col2 = vec3(01.19,0.042,0.07)*1.3;
    _col = mix(_col2,_col,cmod);
//	    _col = vec3(0.15,0.45,0.05)*1.2; // for single colour
	if (Param3 > 3. && length(_col.x) < 1.) // white blobs
		_col = vec3(1.);
    return d1;
}

vec3 calcNormal( in vec3 pos ){
    vec2 e = vec2(1.0,-1.0)*0.5773;
    const float eps = 0.05;
    return normalize( e.xyy*map( pos + e.xyy*eps ) + e.yyx*map( pos + e.yyx*eps ) + e.yxy*map( pos + e.yxy*eps ) + e.xxx*map( pos + e.xxx*eps ) );
}
    

void main()
{
    float dist = 28.0;
    vec3 ro = vec3( dist, cos(time*0.75)*14.0, dist );
    vec3 ta = vec3( 0.0, 0.0, 0.0 );
    vec3 ww = normalize( ta - ro );
    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );
    vec3 vv = normalize( cross(uu,ww));

    vec2 p = (-resolution.xy + 2.0*gl_FragCoord.xy)/resolution;

	  if (Param2 == 3. || Param2 == 4.) {
   	if (p.x > .0) {
            p.x = 2.*p.x - 1.;
        }
        else
        {
            p.x = -1. - p.x*2. ;
        }
    }
	p.x *=.35;
	
    if (Param2 == 2. || Param2 == 4.) {
            if (p.y > .0) {
                p.y = 2.*p.y - 1.;
            }
            else
            {
                p.y = -1. - p.y*2. ;
            }

    }
	p.y *=.75;

	vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );
	const float tmax = 65.0;
	float t = 0.0;
	int breakOut = 40;
	if (Param1 == 2.)
		breakOut = 13;
	else if (Param1 == 3.)
		breakOut = 9;
	else if (Param1 == 4.)
		breakOut = 6;
	for( int i=0; i<40; i++ )
	{
		vec3 pos = ro + t*rd;
		float h = map(pos);
		if( h<0.0001 || t>tmax ) break;
		t += h;
		if (i > breakOut)
			break;
	}
    	
	vec3 col = vec3(0.);
	if( t<tmax )
	{
		vec3 pos = ro + t*rd;
		vec3 nor = calcNormal(pos);

		vec3 dir = normalize(vec3(1.0,0.7,0.0));
		vec3 ref = reflect(rd, nor);
		float spe = max(dot(ref, dir), 0.0);
		vec3 spec = vec3(1.0) * pow(spe, 100.);
		float dif = clamp( dot(nor,dir), 0.05, 1.0 );
		col =  _col*dif;
		col+=spec;
	}      
	col = sqrt( col );
	if (length(col) <.2) // do background patterns
		col = background()/1.5;
	vec3 final_col = vec3(0.);
	if (Param3 == 1.)
		final_col = col;
	    else if (Param3 == 2.)
		final_col = col.rbg;
	    else if (Param3 == 3.)
		final_col = col.gbr;
	    else if (Param3 == 4.) {
		final_col = col;
		}
	    else if (Param3 == 5.) {
		col.g = col.r;
		final_col = col.rbg;
		}
	    else if (Param3 == 6.) {
		final_col = col.rbg;
	    }
	    else if (Param3 == 7.)
	       final_col = vec3((col.x + col.y + col.z)/2.);
	gl_FragColor = vec4( final_col, 1.0 );
}
</script>
	<script id="shader-2-fs" type="f">
		precision highp float;
uniform vec2 resolution;
uniform vec2 mouse;
uniform float time;
uniform float Param1;
uniform float Param2;
uniform float Param3;
uniform float Param4;
const float fRadius = 0.008;
const float ySpeed = 1.25;
const float bubblePopHeight = 1.0;
const float bubbleSpreadDist = 2.0;
vec3 bokeh(vec3 d)
{
	vec2 uv = d.xy -1. + 2.0*gl_FragCoord.xy / resolution.xy;
    uv.x *=  resolution.x / resolution.y;
    
    vec3 color = vec3(0.0);

        // bubbles
    for( int i=0; i<20; i++ )
    {
            // bubble seeds
        float pha = tan(float(i)*6.+1.0)*0.5 + 0.5;
        float siz = pow( cos(float(i)*2.4+4.0) * 0.5 + ySpeed, 4.0 );
        float pox = cos(float(i)*2.55+3.1) * resolution.x / resolution.y;
        
            // buble size, position and color
        float rad = fRadius + sin(float(i))*0.12+0.29;
        vec2  pos = vec2( pox+sin(time/50.+pha+siz), -abs(bubblePopHeight)-rad + (bubbleSpreadDist+2.0*rad)
                         *mod(pha+0.1*(time/5.)*(0.2+0.8*siz),1.0)) * vec2(1.0, 1.0);
        float dis = length( uv - pos );
        vec3  col = mix( vec3(0.2, 0.5, 0.1), vec3(0.2,0.3,0.6), 0.2+0.2*sin(float(i)*sin(time*pox*0.03)+1.9));
        
            // render
        color += col.xyz *(1.- smoothstep( rad*(0.65+0.20*sin(pox*time)), rad, dis )) * (1.0 - cos(pox*time));
    }
	return color;
}

vec3 stripey(vec3 d, int v)
{
vec2 coord = d.xy + gl_FragCoord.xy / resolution;
float color = 0.0;
color += (sin(((coord.x * 50.0) + cos(time + (coord.y * 10.0))) + sin((coord.x * 50.0) + (time * 2.0))) * .125);
//color += (cos(((coord.x * 20.0) + sin(time + (coord.y * 10.0))) + cos((coord.x * 50.0) + (time * 2.0))) * 2.0);
//color += (cos(((coord.x * 30.0) + sin(time + (coord.y * 10.0))) + cos((coord.x * 50.0) + (time * 2.0))) * 2.0);
if (v == 1)
	color += (sin(((coord.x * 10.0) + cos(time + (coord.y * 10.0))) + sin((coord.x * 50.0) + (time * 2.0))) * .5);
return vec3(color + coord.y, color + coord.x, color);
}

vec3 trippy(vec3 d, float v)
{
vec2 uv = d.xy+(gl_FragCoord.xy / resolution.xy);
if (v == 32.) uv.y = 1. - uv.y;
vec2 r;
r = resolution.xy/v;
float t = time/4.;
float c = fract( sin(uv.x * r.x*0.8) *
		 sin(uv.y * r.y*0.08 ) + t ); 
uv.x += (uv.x+uv.y) +  c;
return vec3(c, c*mod(t+uv.x,1.5), 0.5 );
}

float FalloffSpeed = 2.0;
float RotationSpeed = 1.0;
vec4 Color1 = vec4(1.0, 0.0, 0.0, 1.0);
vec4 Color2 = vec4(1.0, 1.0, 0.0, 1.0);
vec3 OrangeTint(vec3 d) {
vec2 uv = (d.xy + gl_FragCoord.xy / resolution.xy) * 2.0 - 1.0;
float T = time * RotationSpeed;
float value = distance(uv, vec2(sin(T), cos(T)));
return vec3(mix(Color1, Color2, value / FalloffSpeed));
}

vec3 rota(vec3 gg){
return vec3(sin(sin(gg.x*10.)+(cos(gg.y*3.2)*2.3)+cos(gg.z*1.3))+sin(gg.x*7.),
	    cos(gg.y*cos(gg.z*1.241)+sin(gg.x*1.17)+cos(gg.y*3.4)), 
	    1.2*cos(gg.y*.9))+sin(gg.x+time*0.1)+cos(gg.z*1.3);
}
vec3 swirls(vec3 d) {
vec2 position = d.xy +gl_FragCoord.yx / resolution.xy;
vec3 gg=vec3(position,time*0.1);
gg=rota(gg);
gg=rota(gg);
gg=rota(gg);
vec3 color = vec3(position.xy,1.);
return vec3(gg);
}

vec3 bgColor = vec3(0.01, 0.3, 0.1);
vec3 rectColor = vec3(0.01, 0.2, 0.3);

const float noiseIntensity = 12.; // 2., 6., 12
const float noiseDefinition = .2;  //.1, .2, .4 slow time
const vec2 glowPos = vec2(-1., 0.);

float random(vec2 co){return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);}

float noise( in vec2 p )
{
p*=noiseIntensity;
vec2 i = floor( p );
vec2 f = fract( p );
vec2 u = f*f*(3.0-2.0*f);
return mix( mix( random( i + vec2(0.0,0.0) ), 
	     random( i + vec2(1.0,0.0) ), u.x),
	mix( random( i + vec2(0.0,1.0) ), 
	     random( i + vec2(1.0,1.0) ), u.x), u.y);
}

float fbm( in vec2 uv )
{	
uv *= 5.0;
mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );
float f  = 0.5000*noise( uv ); uv = m*uv;
f += 0.2500*noise( uv ); uv = m*uv;
f += 0.1250*noise( uv ); uv = m*uv;
f += 0.0625*noise( uv ); uv = m*uv;
f = 0.5 + 0.5*f;
return f;
}

vec3 bg(vec2 uv)
{
float velocity = time/4.6;
float intensity = (sin(uv.y*3.+velocity*2.))*1.1+1.8;
uv.y -= 0.;
vec2 bp = uv+glowPos;
uv *= noiseDefinition;
float rb = fbm(vec2(uv.x*.5-velocity*.03, uv.y))*.21;
uv += rb;
float rz = fbm(uv*.9+vec2(velocity*.35, 0.0));
rz *= dot(bp*intensity/8.,bp)+1.2;
vec3 col = bgColor/(.1-rz);
return sqrt(abs(col));
}

vec3 greenRain(vec3 d)
{
vec2 uv = d.xy + gl_FragCoord.xy / resolution.xy * 2. - 1.;
uv.x *= resolution.x/resolution.y;
return vec3(bg(uv.yx)*(2.-abs(uv.y*2.)));
}

vec3 col2 (vec3 d)
{
vec2 uv = (d.xy + gl_FragCoord.xy / resolution.xy )*6.0;
vec2 uv0=uv;
float i0=1.5;
float i1=0.95;
float i2=1.5;
vec2 i4=vec2(0.0,0.0);
for(int s=0;s<10;s++)
{
	vec2 r;
	r=vec2(cos(uv.y*i0-i4.y+time/i1),sin(uv.x*i0+i4.x+time/i1))/i2;
	r+=vec2(-r.y,r.x)*0.2;
	uv.xy+=r;

	i0*=1.93;
	i1*=1.45; //speed
	i2*=10.9; //blur
	i4+=r.xy*1.0+0.5*time*i1;
}
float r=sin(uv.x-time)*0.2+1.1;
float b=sin(uv.y+time)*0.5+0.5;
float g=sin((sqrt(uv.x*uv.x+uv.y*uv.y)+time))*0.8+0.1;
vec3 c=sqrt(vec3(r*b,g*r,b*g));
return c;
}


vec2 rot(vec2 p, float a)
{
float sa = sin(a), ca = cos(a);
return p * mat2(ca, -sa, sa, ca);
}  

bool intersect(vec3 origin, vec3 ray, float radius, out float t, out vec3 n) {
vec3 L = -origin;
float radiusSquared = radius * radius;
float tca = dot(L, ray);
if (tca < 0.0) return false;
float d2 = dot(L, L) - tca * tca;
if (d2 > radiusSquared) return false;
float thc = sqrt(radiusSquared - d2);
t = tca - thc;
n = normalize(origin + ray * t);
return true;
}

vec3 background()
{
if (Param4 == 2.) return bokeh(vec3(0.));
else if (Param4 == 1.) return col2(vec3(0.));
else if (Param4 == 3.) return (greenRain(vec3(0.))/1.2);
else if (Param4 == 4.) return swirls(vec3(0.))/1.8;
else if (Param4 == 5.) return stripey(vec3(0.),0)/2.;
else return trippy(vec3(0.),13.)/1.5;
}

#define HEIGHT 10. // 10 = ball, 40 = line (horizontal and vertical) 
vec3 _col;

float sdCylinder( vec3 p, vec2 h ){vec2 d = abs(vec2(length(p.xz),p.y)) - h;return min(max(d.x,d.y),.0) + length(max(d,0.0));}
float smin( float a, float b, float k ){float h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );return mix( b, a, h ) - k*h*(1.0-h);}
float smax(float a, float b, float k){return smin(a, b, -k);}
float sminCol( float a, float b, float k, vec3 col1, vec3 col2 ){float h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );_col = mix(col1,col2,h);return mix( b, a, h ) - k*h*(1.0-h);}
vec3 e(vec3 p, vec3 ax, float ro){return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);}

float WaveletNoise(vec3 p, float z, float k) {
    float d=0.,s=1.,m=0., a;
    for(float i=0.; i<3.; i++) {
        vec3 q = p*s, g=fract(floor(q)*vec3(123.34,233.53,314.15));
    	g += dot(g, g+23.234);
		a = fract(g.x*g.y)*1e3 +z*(mod(g.x+g.y, 2.)-1.); // add vorticity
        q = (fract(q)-.5);
        q = e(q, normalize(tan(g+.1)), a);
        d += sin(q.x*10.+z)*smoothstep(.25, .0, dot(q,q))/s;
        p = e(p,normalize(vec3(-1,1,0)),atan(sqrt(2.)))+i; //rotate along the magic angle
        m += 1./s;
        s *= k; 
    }
    return d/m;
}
  
float map( in vec3 pos )
{
    float nx = WaveletNoise(pos*0.1+vec3(0.0,time/3.,0.0), time*.1, 1.15)*1.9;
    float nz = WaveletNoise(pos*0.1+vec3(0.0,time/3.,0.0) + 10.0, time*.1, 1.15)*1.9;
    vec3 p2 = pos;
    p2.x += nx;
    p2.z += nz;
    float d1 = sdCylinder(p2,vec2(4.0,HEIGHT))-1.0;
    d1 = smax(d1-sin(time*7.0+pos.y*0.4),d1,-3.0);
    float cmod = 0.5+sin(nx*1.3-nz*2.0)*0.5;
    _col = vec3(0.55,0.45,0.05)*1.2;
    vec3 _col2 = vec3(01.19,0.042,0.07)*1.3;
    _col = mix(_col2,_col,cmod);
//	    _col = vec3(0.15,0.45,0.05)*1.2; // for single colour
	if (Param3 > 3. && length(_col.x) < 1.) // white blobs
		_col = vec3(1.);
    return d1;
}

vec3 calcNormal( in vec3 pos ){
    vec2 e = vec2(1.0,-1.0)*0.5773;
    const float eps = 0.05;
    return normalize( e.xyy*map( pos + e.xyy*eps ) + e.yyx*map( pos + e.yyx*eps ) + e.yxy*map( pos + e.yxy*eps ) + e.xxx*map( pos + e.xxx*eps ) );
}
    

void main()
{
    float dist = 28.0;
    vec3 ro = vec3( dist, cos(time*0.75)*14.0, dist );
    vec3 ta = vec3( 0.0, 0.0, 0.0 );
    vec3 ww = normalize( ta - ro );
    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );
    vec3 vv = normalize( cross(uu,ww));

    vec2 p = (-resolution.xy + 2.0*gl_FragCoord.xy)/resolution;

	  if (Param2 == 3. || Param2 == 4.) {
   	if (p.x > .0) {
            p.x = 2.*p.x - 1.;
        }
        else
        {
            p.x = -1. - p.x*2. ;
        }
    }
	p.x *=.4;
	
    if (Param2 == 2. || Param2 == 4.) {
            if (p.y > .0) {
                p.y = 2.*p.y - 1.;
            }
            else
            {
                p.y = -1. - p.y*2. ;
            }

    }
	p.y *=.75;
	    	
	p.y = p.y/2.+.15; // for pillar with gap at top
	
	vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );
	const float tmax = 65.0;
	float t = 0.0;
	int breakOut = 40;
	if (Param1 == 2.)
		breakOut = 13;
	else if (Param1 == 3.)
		breakOut = 9;
	else if (Param1 == 4.)
		breakOut = 6;
	for( int i=0; i<40; i++ )
	{
		vec3 pos = ro + t*rd;
		float h = map(pos);
		if( h<0.0001 || t>tmax ) break;
		t += h;
		if (i > breakOut)
			break;
	}
    	
	vec3 col = vec3(0.);
	if( t<tmax )
	{
		vec3 pos = ro + t*rd;
		vec3 nor = calcNormal(pos);

		vec3 dir = normalize(vec3(1.0,0.7,0.0));
		vec3 ref = reflect(rd, nor);
		float spe = max(dot(ref, dir), 0.0);
		vec3 spec = vec3(1.0) * pow(spe, 100.);
		float dif = clamp( dot(nor,dir), 0.05, 1.0 );
		col =  _col*dif;
		col+=spec;
	}      
	col = sqrt( col );
	if (length(col) <.2) // do background patterns
		col = background()/1.5;
	vec3 final_col = vec3(0.);
	if (Param3 == 1.)
		final_col = col;
	    else if (Param3 == 2.)
		final_col = col.rbg;
	    else if (Param3 == 3.)
		final_col = col.gbr;
	    else if (Param3 == 4.) {
		final_col = col;
		}
	    else if (Param3 == 5.) {
		col.g = col.r;
		final_col = col.rbg;
		}
	    else if (Param3 == 6.) {
		final_col = col.rbg;
	    }
	    else if (Param3 == 7.)
	       final_col = vec3((col.x + col.y + col.z)/2.);
	gl_FragColor = vec4( final_col, 1.0 );
}
</script>
	<script id="shader-3-fs" type="f">
		precision highp float;
uniform vec2 resolution;
uniform vec2 mouse;
uniform float time;
uniform float Param1;
uniform float Param2;
uniform float Param3;
uniform float Param4;
const float fRadius = 0.008;
const float ySpeed = 1.25;
const float bubblePopHeight = 1.0;
const float bubbleSpreadDist = 2.0;
vec3 bokeh(vec3 d)
{
	vec2 uv = d.xy -1. + 2.0*gl_FragCoord.xy / resolution.xy;
    uv.x *=  resolution.x / resolution.y;
    
    vec3 color = vec3(0.0);

        // bubbles
    for( int i=0; i<20; i++ )
    {
            // bubble seeds
        float pha = tan(float(i)*6.+1.0)*0.5 + 0.5;
        float siz = pow( cos(float(i)*2.4+4.0) * 0.5 + ySpeed, 4.0 );
        float pox = cos(float(i)*2.55+3.1) * resolution.x / resolution.y;
        
            // buble size, position and color
        float rad = fRadius + sin(float(i))*0.12+0.29;
        vec2  pos = vec2( pox+sin(time/50.+pha+siz), -abs(bubblePopHeight)-rad + (bubbleSpreadDist+2.0*rad)
                         *mod(pha+0.1*(time/5.)*(0.2+0.8*siz),1.0)) * vec2(1.0, 1.0);
        float dis = length( uv - pos );
        vec3  col = mix( vec3(0.2, 0.5, 0.1), vec3(0.2,0.3,0.6), 0.2+0.2*sin(float(i)*sin(time*pox*0.03)+1.9));
        
            // render
        color += col.xyz *(1.- smoothstep( rad*(0.65+0.20*sin(pox*time)), rad, dis )) * (1.0 - cos(pox*time));
    }
	return color;
}

vec3 stripey(vec3 d, int v)
{
vec2 coord = d.xy + gl_FragCoord.xy / resolution;
float color = 0.0;
color += (sin(((coord.x * 50.0) + cos(time + (coord.y * 10.0))) + sin((coord.x * 50.0) + (time * 2.0))) * .125);
//color += (cos(((coord.x * 20.0) + sin(time + (coord.y * 10.0))) + cos((coord.x * 50.0) + (time * 2.0))) * 2.0);
//color += (cos(((coord.x * 30.0) + sin(time + (coord.y * 10.0))) + cos((coord.x * 50.0) + (time * 2.0))) * 2.0);
if (v == 1)
	color += (sin(((coord.x * 10.0) + cos(time + (coord.y * 10.0))) + sin((coord.x * 50.0) + (time * 2.0))) * .5);
return vec3(color + coord.y, color + coord.x, color);
}

vec3 trippy(vec3 d, float v)
{
vec2 uv = d.xy+(gl_FragCoord.xy / resolution.xy);
if (v == 32.) uv.y = 1. - uv.y;
vec2 r;
r = resolution.xy/v;
float t = time/4.;
float c = fract( sin(uv.x * r.x*0.8) *
		 sin(uv.y * r.y*0.08 ) + t ); 
uv.x += (uv.x+uv.y) +  c;
return vec3(c, c*mod(t+uv.x,1.5), 0.5 );
}

float FalloffSpeed = 2.0;
float RotationSpeed = 1.0;
vec4 Color1 = vec4(1.0, 0.0, 0.0, 1.0);
vec4 Color2 = vec4(1.0, 1.0, 0.0, 1.0);
vec3 OrangeTint(vec3 d) {
vec2 uv = (d.xy + gl_FragCoord.xy / resolution.xy) * 2.0 - 1.0;
float T = time * RotationSpeed;
float value = distance(uv, vec2(sin(T), cos(T)));
return vec3(mix(Color1, Color2, value / FalloffSpeed));
}

vec3 rota(vec3 gg){
return vec3(sin(sin(gg.x*10.)+(cos(gg.y*3.2)*2.3)+cos(gg.z*1.3))+sin(gg.x*7.),
	    cos(gg.y*cos(gg.z*1.241)+sin(gg.x*1.17)+cos(gg.y*3.4)), 
	    1.2*cos(gg.y*.9))+sin(gg.x+time*0.1)+cos(gg.z*1.3);
}
vec3 swirls(vec3 d) {
vec2 position = d.xy +gl_FragCoord.yx / resolution.xy;
vec3 gg=vec3(position,time*0.1);
gg=rota(gg);
gg=rota(gg);
gg=rota(gg);
vec3 color = vec3(position.xy,1.);
return vec3(gg);
}

vec3 bgColor = vec3(0.01, 0.3, 0.1);
vec3 rectColor = vec3(0.01, 0.2, 0.3);

const float noiseIntensity = 12.; // 2., 6., 12
const float noiseDefinition = .2;  //.1, .2, .4 slow time
const vec2 glowPos = vec2(-1., 0.);

float random(vec2 co){return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);}

float noise( in vec2 p )
{
p*=noiseIntensity;
vec2 i = floor( p );
vec2 f = fract( p );
vec2 u = f*f*(3.0-2.0*f);
return mix( mix( random( i + vec2(0.0,0.0) ), 
	     random( i + vec2(1.0,0.0) ), u.x),
	mix( random( i + vec2(0.0,1.0) ), 
	     random( i + vec2(1.0,1.0) ), u.x), u.y);
}

float fbm( in vec2 uv )
{	
uv *= 5.0;
mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );
float f  = 0.5000*noise( uv ); uv = m*uv;
f += 0.2500*noise( uv ); uv = m*uv;
f += 0.1250*noise( uv ); uv = m*uv;
f += 0.0625*noise( uv ); uv = m*uv;
f = 0.5 + 0.5*f;
return f;
}

vec3 bg(vec2 uv)
{
float velocity = time/4.6;
float intensity = (sin(uv.y*3.+velocity*2.))*1.1+1.8;
uv.y -= 0.;
vec2 bp = uv+glowPos;
uv *= noiseDefinition;
float rb = fbm(vec2(uv.x*.5-velocity*.03, uv.y))*.21;
uv += rb;
float rz = fbm(uv*.9+vec2(velocity*.35, 0.0));
rz *= dot(bp*intensity/8.,bp)+1.2;
vec3 col = bgColor/(.1-rz);
return sqrt(abs(col));
}

vec3 greenRain(vec3 d)
{
vec2 uv = d.xy + gl_FragCoord.xy / resolution.xy * 2. - 1.;
uv.x *= resolution.x/resolution.y;
return vec3(bg(uv.yx)*(2.-abs(uv.y*2.)));
}

vec3 col2 (vec3 d)
{
vec2 uv = (d.xy + gl_FragCoord.xy / resolution.xy )*6.0;
vec2 uv0=uv;
float i0=1.5;
float i1=0.95;
float i2=1.5;
vec2 i4=vec2(0.0,0.0);
for(int s=0;s<10;s++)
{
	vec2 r;
	r=vec2(cos(uv.y*i0-i4.y+time/i1),sin(uv.x*i0+i4.x+time/i1))/i2;
	r+=vec2(-r.y,r.x)*0.2;
	uv.xy+=r;

	i0*=1.93;
	i1*=1.45; //speed
	i2*=10.9; //blur
	i4+=r.xy*1.0+0.5*time*i1;
}
float r=sin(uv.x-time)*0.2+1.1;
float b=sin(uv.y+time)*0.5+0.5;
float g=sin((sqrt(uv.x*uv.x+uv.y*uv.y)+time))*0.8+0.1;
vec3 c=sqrt(vec3(r*b,g*r,b*g));
return c;
}


vec2 rot(vec2 p, float a)
{
float sa = sin(a), ca = cos(a);
return p * mat2(ca, -sa, sa, ca);
}  

bool intersect(vec3 origin, vec3 ray, float radius, out float t, out vec3 n) {
vec3 L = -origin;
float radiusSquared = radius * radius;
float tca = dot(L, ray);
if (tca < 0.0) return false;
float d2 = dot(L, L) - tca * tca;
if (d2 > radiusSquared) return false;
float thc = sqrt(radiusSquared - d2);
t = tca - thc;
n = normalize(origin + ray * t);
return true;
}

vec3 background()
{
if (Param4 == 2.) return bokeh(vec3(0.));
else if (Param4 == 1.) return col2(vec3(0.));
else if (Param4 == 3.) return (greenRain(vec3(0.))/1.2);
else if (Param4 == 4.) return swirls(vec3(0.))/1.8;
else if (Param4 == 5.) return stripey(vec3(0.),0)/2.;
else return trippy(vec3(0.),13.)/1.5;
}

#define HEIGHT 10. // 10 = ball, 40 = line (horizontal and vertical) 
vec3 _col;

float sdCylinder( vec3 p, vec2 h ){vec2 d = abs(vec2(length(p.xz),p.y)) - h;return min(max(d.x,d.y),.0) + length(max(d,0.0));}
float smin( float a, float b, float k ){float h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );return mix( b, a, h ) - k*h*(1.0-h);}
float smax(float a, float b, float k){return smin(a, b, -k);}
float sminCol( float a, float b, float k, vec3 col1, vec3 col2 ){float h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );_col = mix(col1,col2,h);return mix( b, a, h ) - k*h*(1.0-h);}
vec3 e(vec3 p, vec3 ax, float ro){return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);}

float WaveletNoise(vec3 p, float z, float k) {
    float d=0.,s=1.,m=0., a;
    for(float i=0.; i<3.; i++) {
        vec3 q = p*s, g=fract(floor(q)*vec3(123.34,233.53,314.15));
    	g += dot(g, g+23.234);
		a = fract(g.x*g.y)*1e3 +z*(mod(g.x+g.y, 2.)-1.); // add vorticity
        q = (fract(q)-.5);
        q = e(q, normalize(tan(g+.1)), a);
        d += sin(q.x*10.+z)*smoothstep(.25, .0, dot(q,q))/s;
        p = e(p,normalize(vec3(-1,1,0)),atan(sqrt(2.)))+i; //rotate along the magic angle
        m += 1./s;
        s *= k; 
    }
    return d/m;
}
  
float map( in vec3 pos )
{
    float nx = WaveletNoise(pos*0.1+vec3(0.0,time/3.,0.0), time*.1, 1.15)*1.9;
    float nz = WaveletNoise(pos*0.1+vec3(0.0,time/3.,0.0) + 10.0, time*.1, 1.15)*1.9;
    vec3 p2 = pos;
    p2.x += nx;
    p2.z += nz;
    float d1 = sdCylinder(p2,vec2(4.0,HEIGHT))-1.0;
    d1 = smax(d1-sin(time*7.0+pos.y*0.4),d1,-3.0);
    float cmod = 0.5+sin(nx*1.3-nz*2.0)*0.5;
    _col = vec3(0.55,0.45,0.05)*1.2;
    vec3 _col2 = vec3(01.19,0.042,0.07)*1.3;
    _col = mix(_col2,_col,cmod);
//	    _col = vec3(0.15,0.45,0.05)*1.2; // for single colour
	if (Param3 > 3. && length(_col.x) < 1.) // white blobs
		_col = vec3(1.);
    return d1;
}

vec3 calcNormal( in vec3 pos ){
    vec2 e = vec2(1.0,-1.0)*0.5773;
    const float eps = 0.05;
    return normalize( e.xyy*map( pos + e.xyy*eps ) + e.yyx*map( pos + e.yyx*eps ) + e.yxy*map( pos + e.yxy*eps ) + e.xxx*map( pos + e.xxx*eps ) );
}
    

void main()
{
    float dist = 28.0;
    vec3 ro = vec3( dist, cos(time*0.75)*14.0, dist );
    vec3 ta = vec3( 0.0, 0.0, 0.0 );
    vec3 ww = normalize( ta - ro );
    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );
    vec3 vv = normalize( cross(uu,ww));

    vec2 p = (-resolution.xy + 2.0*gl_FragCoord.xy)/resolution;

	  if (Param2 == 3. || Param2 == 4.) {
   	if (p.x > .0) {
            p.x = 2.*p.x - 1.;
        }
        else
        {
            p.x = -1. - p.x*2. ;
        }
    }
	p.x *=.35;
	
    if (Param2 == 2. || Param2 == 4.) {
            if (p.y > .0) {
                p.y = 2.*p.y - 1.;
            }
            else
            {
                p.y = -1. - p.y*2. ;
            }

    }
	p.y *=.25;

	vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );
	const float tmax = 65.0;
	float t = 0.0;
	int breakOut = 40;
	if (Param1 == 2.)
		breakOut = 13;
	else if (Param1 == 3.)
		breakOut = 9;
	else if (Param1 == 4.)
		breakOut = 6;
	for( int i=0; i<40; i++ )
	{
		vec3 pos = ro + t*rd;
		float h = map(pos);
		if( h<0.0001 || t>tmax ) break;
		t += h;
		if (i > breakOut)
			break;
	}
    	
	vec3 col = vec3(0.);
	if( t<tmax )
	{
		vec3 pos = ro + t*rd;
		vec3 nor = calcNormal(pos);

		vec3 dir = normalize(vec3(1.0,0.7,0.0));
		vec3 ref = reflect(rd, nor);
		float spe = max(dot(ref, dir), 0.0);
		vec3 spec = vec3(1.0) * pow(spe, 100.);
		float dif = clamp( dot(nor,dir), 0.05, 1.0 );
		col =  _col*dif;
		col+=spec;
	}      
	col = sqrt( col );
	if (length(col) <.2) // do background patterns
		col = background()/1.5;
	vec3 final_col = vec3(0.);
	if (Param3 == 1.)
		final_col = col;
	    else if (Param3 == 2.)
		final_col = col.rbg;
	    else if (Param3 == 3.)
		final_col = col.gbr;
	    else if (Param3 == 4.) {
		final_col = col;
		}
	    else if (Param3 == 5.) {
		col.g = col.r;
		final_col = col.rbg;
		}
	    else if (Param3 == 6.) {
		final_col = col.rbg;
	    }
	    else if (Param3 == 7.)
	       final_col = vec3((col.x + col.y + col.z)/2.);
	gl_FragColor = vec4( final_col, 1.0 );
}
</script>
	<script id="shader-4-fs" type="f">
		precision highp float;
uniform vec2 resolution;
uniform vec2 mouse;
uniform float time;
uniform float Param1;
uniform float Param2;
uniform float Param3;
uniform float Param4;
const float fRadius = 0.008;
const float ySpeed = 1.25;
const float bubblePopHeight = 1.0;
const float bubbleSpreadDist = 2.0;
vec3 bokeh(vec3 d)
{
	vec2 uv = d.xy -1. + 2.0*gl_FragCoord.xy / resolution.xy;
    uv.x *=  resolution.x / resolution.y;
    
    vec3 color = vec3(0.0);

        // bubbles
    for( int i=0; i<20; i++ )
    {
            // bubble seeds
        float pha = tan(float(i)*6.+1.0)*0.5 + 0.5;
        float siz = pow( cos(float(i)*2.4+4.0) * 0.5 + ySpeed, 4.0 );
        float pox = cos(float(i)*2.55+3.1) * resolution.x / resolution.y;
        
            // buble size, position and color
        float rad = fRadius + sin(float(i))*0.12+0.29;
        vec2  pos = vec2( pox+sin(time/50.+pha+siz), -abs(bubblePopHeight)-rad + (bubbleSpreadDist+2.0*rad)
                         *mod(pha+0.1*(time/5.)*(0.2+0.8*siz),1.0)) * vec2(1.0, 1.0);
        float dis = length( uv - pos );
        vec3  col = mix( vec3(0.2, 0.5, 0.1), vec3(0.2,0.3,0.6), 0.2+0.2*sin(float(i)*sin(time*pox*0.03)+1.9));
        
            // render
        color += col.xyz *(1.- smoothstep( rad*(0.65+0.20*sin(pox*time)), rad, dis )) * (1.0 - cos(pox*time));
    }
	return color;
}

vec3 stripey(vec3 d, int v)
{
vec2 coord = d.xy + gl_FragCoord.xy / resolution;
float color = 0.0;
color += (sin(((coord.x * 50.0) + cos(time + (coord.y * 10.0))) + sin((coord.x * 50.0) + (time * 2.0))) * .125);
//color += (cos(((coord.x * 20.0) + sin(time + (coord.y * 10.0))) + cos((coord.x * 50.0) + (time * 2.0))) * 2.0);
//color += (cos(((coord.x * 30.0) + sin(time + (coord.y * 10.0))) + cos((coord.x * 50.0) + (time * 2.0))) * 2.0);
if (v == 1)
	color += (sin(((coord.x * 10.0) + cos(time + (coord.y * 10.0))) + sin((coord.x * 50.0) + (time * 2.0))) * .5);
return vec3(color + coord.y, color + coord.x, color);
}

vec3 trippy(vec3 d, float v)
{
vec2 uv = d.xy+(gl_FragCoord.xy / resolution.xy);
if (v == 32.) uv.y = 1. - uv.y;
vec2 r;
r = resolution.xy/v;
float t = time/4.;
float c = fract( sin(uv.x * r.x*0.8) *
		 sin(uv.y * r.y*0.08 ) + t ); 
uv.x += (uv.x+uv.y) +  c;
return vec3(c, c*mod(t+uv.x,1.5), 0.5 );
}

float FalloffSpeed = 2.0;
float RotationSpeed = 1.0;
vec4 Color1 = vec4(1.0, 0.0, 0.0, 1.0);
vec4 Color2 = vec4(1.0, 1.0, 0.0, 1.0);
vec3 OrangeTint(vec3 d) {
vec2 uv = (d.xy + gl_FragCoord.xy / resolution.xy) * 2.0 - 1.0;
float T = time * RotationSpeed;
float value = distance(uv, vec2(sin(T), cos(T)));
return vec3(mix(Color1, Color2, value / FalloffSpeed));
}

vec3 rota(vec3 gg){
return vec3(sin(sin(gg.x*10.)+(cos(gg.y*3.2)*2.3)+cos(gg.z*1.3))+sin(gg.x*7.),
	    cos(gg.y*cos(gg.z*1.241)+sin(gg.x*1.17)+cos(gg.y*3.4)), 
	    1.2*cos(gg.y*.9))+sin(gg.x+time*0.1)+cos(gg.z*1.3);
}
vec3 swirls(vec3 d) {
vec2 position = d.xy +gl_FragCoord.yx / resolution.xy;
vec3 gg=vec3(position,time*0.1);
gg=rota(gg);
gg=rota(gg);
gg=rota(gg);
vec3 color = vec3(position.xy,1.);
return vec3(gg);
}

vec3 bgColor = vec3(0.01, 0.3, 0.1);
vec3 rectColor = vec3(0.01, 0.2, 0.3);

const float noiseIntensity = 12.; // 2., 6., 12
const float noiseDefinition = .2;  //.1, .2, .4 slow time
const vec2 glowPos = vec2(-1., 0.);

float random(vec2 co){return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);}

float noise( in vec2 p )
{
p*=noiseIntensity;
vec2 i = floor( p );
vec2 f = fract( p );
vec2 u = f*f*(3.0-2.0*f);
return mix( mix( random( i + vec2(0.0,0.0) ), 
	     random( i + vec2(1.0,0.0) ), u.x),
	mix( random( i + vec2(0.0,1.0) ), 
	     random( i + vec2(1.0,1.0) ), u.x), u.y);
}

float fbm( in vec2 uv )
{	
uv *= 5.0;
mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );
float f  = 0.5000*noise( uv ); uv = m*uv;
f += 0.2500*noise( uv ); uv = m*uv;
f += 0.1250*noise( uv ); uv = m*uv;
f += 0.0625*noise( uv ); uv = m*uv;
f = 0.5 + 0.5*f;
return f;
}

vec3 bg(vec2 uv)
{
float velocity = time/4.6;
float intensity = (sin(uv.y*3.+velocity*2.))*1.1+1.8;
uv.y -= 0.;
vec2 bp = uv+glowPos;
uv *= noiseDefinition;
float rb = fbm(vec2(uv.x*.5-velocity*.03, uv.y))*.21;
uv += rb;
float rz = fbm(uv*.9+vec2(velocity*.35, 0.0));
rz *= dot(bp*intensity/8.,bp)+1.2;
vec3 col = bgColor/(.1-rz);
return sqrt(abs(col));
}

vec3 greenRain(vec3 d)
{
vec2 uv = d.xy + gl_FragCoord.xy / resolution.xy * 2. - 1.;
uv.x *= resolution.x/resolution.y;
return vec3(bg(uv.yx)*(2.-abs(uv.y*2.)));
}

vec3 col2 (vec3 d)
{
vec2 uv = (d.xy + gl_FragCoord.xy / resolution.xy )*6.0;
vec2 uv0=uv;
float i0=1.5;
float i1=0.95;
float i2=1.5;
vec2 i4=vec2(0.0,0.0);
for(int s=0;s<10;s++)
{
	vec2 r;
	r=vec2(cos(uv.y*i0-i4.y+time/i1),sin(uv.x*i0+i4.x+time/i1))/i2;
	r+=vec2(-r.y,r.x)*0.2;
	uv.xy+=r;

	i0*=1.93;
	i1*=1.45; //speed
	i2*=10.9; //blur
	i4+=r.xy*1.0+0.5*time*i1;
}
float r=sin(uv.x-time)*0.2+1.1;
float b=sin(uv.y+time)*0.5+0.5;
float g=sin((sqrt(uv.x*uv.x+uv.y*uv.y)+time))*0.8+0.1;
vec3 c=sqrt(vec3(r*b,g*r,b*g));
return c;
}


vec2 rot(vec2 p, float a)
{
float sa = sin(a), ca = cos(a);
return p * mat2(ca, -sa, sa, ca);
}  

bool intersect(vec3 origin, vec3 ray, float radius, out float t, out vec3 n) {
vec3 L = -origin;
float radiusSquared = radius * radius;
float tca = dot(L, ray);
if (tca < 0.0) return false;
float d2 = dot(L, L) - tca * tca;
if (d2 > radiusSquared) return false;
float thc = sqrt(radiusSquared - d2);
t = tca - thc;
n = normalize(origin + ray * t);
return true;
}

vec3 background()
{
if (Param4 == 2.) return bokeh(vec3(0.));
else if (Param4 == 1.) return col2(vec3(0.));
else if (Param4 == 3.) return (greenRain(vec3(0.))/1.2);
else if (Param4 == 4.) return swirls(vec3(0.))/1.8;
else if (Param4 == 5.) return stripey(vec3(0.),0)/2.;
else return trippy(vec3(0.),13.)/1.5;
}

#define HEIGHT 10. // 10 = ball, 40 = line (horizontal and vertical) 
vec3 _col;

float sdCylinder( vec3 p, vec2 h ){vec2 d = abs(vec2(length(p.xz),p.y)) - h;return min(max(d.x,d.y),.0) + length(max(d,0.0));}
float smin( float a, float b, float k ){float h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );return mix( b, a, h ) - k*h*(1.0-h);}
float smax(float a, float b, float k){return smin(a, b, -k);}
float sminCol( float a, float b, float k, vec3 col1, vec3 col2 ){float h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );_col = mix(col1,col2,h);return mix( b, a, h ) - k*h*(1.0-h);}
vec3 e(vec3 p, vec3 ax, float ro){return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);}

float WaveletNoise(vec3 p, float z, float k) {
    float d=0.,s=1.,m=0., a;
    for(float i=0.; i<3.; i++) {
        vec3 q = p*s, g=fract(floor(q)*vec3(123.34,233.53,314.15));
    	g += dot(g, g+23.234);
		a = fract(g.x*g.y)*1e3 +z*(mod(g.x+g.y, 2.)-1.); // add vorticity
        q = (fract(q)-.5);
        q = e(q, normalize(tan(g+.1)), a);
        d += sin(q.x*10.+z)*smoothstep(.25, .0, dot(q,q))/s;
        p = e(p,normalize(vec3(-1,1,0)),atan(sqrt(2.)))+i; //rotate along the magic angle
        m += 1./s;
        s *= k; 
    }
    return d/m;
}
  
float map( in vec3 pos )
{
    float nx = WaveletNoise(pos*0.1+vec3(0.0,time/3.,0.0), time*.1, 1.15)*1.9;
    float nz = WaveletNoise(pos*0.1+vec3(0.0,time/3.,0.0) + 10.0, time*.1, 1.15)*1.9;
    vec3 p2 = pos;
    p2.x += nx;
    p2.z += nz;
    float d1 = sdCylinder(p2,vec2(4.0,HEIGHT))-1.0;
    d1 = smax(d1-sin(time*7.0+pos.y*0.4),d1,-3.0);
    float cmod = 0.5+sin(nx*1.3-nz*2.0)*0.5;
    _col = vec3(0.55,0.45,0.05)*1.2;
    vec3 _col2 = vec3(01.19,0.042,0.07)*1.3;
    _col = mix(_col2,_col,cmod);
//	    _col = vec3(0.15,0.45,0.05)*1.2; // for single colour
	if (Param3 > 3. && length(_col.x) < 1.) // white blobs
		_col = vec3(1.);
    return d1;
}

vec3 calcNormal( in vec3 pos ){
    vec2 e = vec2(1.0,-1.0)*0.5773;
    const float eps = 0.05;
    return normalize( e.xyy*map( pos + e.xyy*eps ) + e.yyx*map( pos + e.yyx*eps ) + e.yxy*map( pos + e.yxy*eps ) + e.xxx*map( pos + e.xxx*eps ) );
}
    

void main()
{
    float dist = 28.0;
    vec3 ro = vec3( dist, cos(time*0.75)*14.0, dist );
    vec3 ta = vec3( 0.0, 0.0, 0.0 );
    vec3 ww = normalize( ta - ro );
    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );
    vec3 vv = normalize( cross(uu,ww));

    vec2 p = (-resolution.xy + 2.0*gl_FragCoord.xy)/resolution;

	  if (Param2 == 3. || Param2 == 4.) {
   	if (p.x > .0) {
            p.x = 2.*p.x - 1.;
        }
        else
        {
            p.x = -1. - p.x*2. ;
        }
    }
	p.x *=.35;
	
    if (Param2 == 2. || Param2 == 4.) {
            if (p.y > .0) {
                p.y = 2.*p.y - 1.;
            }
            else
            {
                p.y = -1. - p.y*2. ;
            }

    }
	p.y *=.75;
	    	
	//p.y = p.y/2.+.15; // for pillar with gap at top
	
	p = p.yx; // these three lines make it horizontal
	p.x *= .6;
	p.y /= 1.5;
	
	vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );
	const float tmax = 65.0;
	float t = 0.0;
	int breakOut = 40;
	if (Param1 == 2.)
		breakOut = 13;
	else if (Param1 == 3.)
		breakOut = 9;
	else if (Param1 == 4.)
		breakOut = 6;
	for( int i=0; i<40; i++ )
	{
		vec3 pos = ro + t*rd;
		float h = map(pos);
		if( h<0.0001 || t>tmax ) break;
		t += h;
		if (i > breakOut)
			break;
	}
    	
	vec3 col = vec3(0.);
	if( t<tmax )
	{
		vec3 pos = ro + t*rd;
		vec3 nor = calcNormal(pos);

		vec3 dir = normalize(vec3(1.0,0.7,0.0));
		vec3 ref = reflect(rd, nor);
		float spe = max(dot(ref, dir), 0.0);
		vec3 spec = vec3(1.0) * pow(spe, 100.);
		float dif = clamp( dot(nor,dir), 0.05, 1.0 );
		col =  _col*dif;
		col+=spec;
	}      
	col = sqrt( col );
	if (length(col) <.2) // do background patterns
		col = background()/1.5;
	vec3 final_col = vec3(0.);
	if (Param3 == 1.)
		final_col = col;
	    else if (Param3 == 2.)
		final_col = col.rbg;
	    else if (Param3 == 3.)
		final_col = col.gbr;
	    else if (Param3 == 4.) {
		final_col = col;
		}
	    else if (Param3 == 5.) {
		col.g = col.r;
		final_col = col.rbg;
		}
	    else if (Param3 == 6.) {
		final_col = col.rbg;
	    }
	    else if (Param3 == 7.)
	       final_col = vec3((col.x + col.y + col.z)/2.);
	gl_FragColor = vec4( final_col, 1.0 );
}
</script>
	<script id="shader-vs" type="v">
		attribute vec3 aVertexPosition;attribute vec2 aTextureCoord;uniform mat4 uMVMatrix;uniform mat4 uPMatrix;void main(void){gl_Position=uPMatrix*uMVMatrix*vec4(aVertexPosition,1.);}
</script>
</head>

<body>
	<div id="container">
		<div id="main">
			<canvas id="webgl-canvas" style="border: none;" width="1500" height="1000"></canvas>
			<splash class="btn" enabled></splash>
			<button class="btn" enabled></button>
			<button1 class="btn" enabled></button1>
			<button2 class="btn" enabled></button2>
			<button3 class="btn" enabled></button3>
			<buttonl class="btn" enabled></buttonl>
			<buttonr class="btn" enabled></buttonr>
			<audio id="audio" autobuffer="autobuffer" preload="auto">
				<source src="plazma.mp3" type="audio/mp3" />
				<source src="plazma.ogg" type="audio/ogg" />
				<source src="plazma.aac" type="audio/aac" />
				<audio id="audio1" autobuffer="autobuffer" preload="auto">
					<source src="plazma1.mp3" type="audio/mp3" />
					<source src="plazma1.ogg" type="audio/ogg" />
					<source src="plazma1.aac" type="audio/aac" />
					<audio id="audio2" autobuffer="autobuffer" preload="auto">
						<source src="plazma2.mp3" type="audio/mp3" />
						<source src="plazma2.ogg" type="audio/ogg" />
						<source src="plazma2.aac" type="audio/aac" />
					</audio>
		</div>
	</div>
</body>

</html>
